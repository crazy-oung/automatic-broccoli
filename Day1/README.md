<details>
  <summary>목차</summary>
  <div markdown="1">
  
- [DAY1 역사](#day1-역사)
  - [0. static stie!로 시작](#0-static-stie로-시작)
    - [정적웹 (Static Site)?](#정적웹-static-site)
    - [정적웹에 접속하면 일어나는 일](#정적웹에-접속하면-일어나는-일)
    - [정적웹에는 어떤게 있을까](#정적웹에는-어떤게-있을까)
    - [정적웹이 아닌 것들](#정적웹이-아닌-것들)
    - [static site로 시작한 이유](#static-site로-시작한-이유)
  - [1. ajax 등장 배경](#1-ajax-등장-배경)
    - [ajax (Asynchronous Javascript And XML)?](#ajax-asynchronous-javascript-and-xml)
    - [ajax 등장 이전](#ajax-등장-이전)
    - [ajax 등장 이후](#ajax-등장-이후)
    - [ajax 장점](#ajax-장점)
    - [ajax 단점](#ajax-단점)
  - [2. webpack 등장 배경](#2-webpack-등장-배경)
    - [webpack?](#webpack)
    - [웹팩 등장 이전](#웹팩-등장-이전)
    - [웹팩 등장 이후](#웹팩-등장-이후)
    - [웹팩 문제점](#웹팩-문제점)
  - [3. SPA 등장배경](#3-spa-등장배경)
    - [SPA (Single Page Application)?](#spa-single-page-application)
    - [SPA가 사용하는 방식](#spa가-사용하는-방식)
    - [CSR (clien side rendering)?](#csr-clien-side-rendering)
    - [CSR 과정](#csr-과정)
    - [CSR 장점](#csr-장점)
    - [CSR 단점](#csr-단점)
  - [4. SSR 등장배경](#4-ssr-등장배경)
    - [SSR (Server Side Rendering)?](#ssr-server-side-rendering)
    - [SSR이 사용되는 곳?](#ssr이-사용되는-곳)
    - [SSR 과정](#ssr-과정)
    - [SSR 장점](#ssr-장점)
    - [SSR 단점](#ssr-단점)
    - [SSR 과 CSR 비교](#ssr-과-csr-비교)
  - [5. SSG 재등장 배경](#5-ssg-재등장-배경)
    - [SSG (Static Site Generation)?](#ssg-static-site-generation)
    - [SSG로 다시 돌아온 이유](#ssg로-다시-돌아온-이유)
    - [SSG로 부하 감소 및 검색최적화](#ssg로-부하-감소-및-검색최적화)
    - [SSG 장점](#ssg-장점)
    - [SSG 단점](#ssg-단점)
  - [부록.](#부록)
    - [동적웹 (Sematic Engine Optimization)?](#동적웹-sematic-engine-optimization)
    - [마크업언어?](#마크업언어)
    - [마크업](#마크업)
      - [mark를 up한다](#mark를-up한다)
    - [SEO (Search Engine Optimization)?](#seo-search-engine-optimization)
    - [CDN (Content Delivery Network)?](#cdn-content-delivery-network)
      - [CDN 작동원리](#cdn-작동원리)
  - [JAMstack](#jamstack)
  </div>
</details>

---

# DAY1 역사

## 0. static stie!로 시작
### 정적웹 (Static Site)?
- 코드가 바뀌지않는 언제 접속해도 계속 같은 리소스와 코드를 건네주는 웹사이트
  - 서버에 사전에 저장되어있던 HTML을 그대호 반환
- 초기에는 HTML 코드만 클라이언트에게 전송해주었었음
- HTML, CSS, Javascript 코드들, 이미지, 동영상 등의 파일들이 변하지 않음

### 정적웹에 접속하면 일어나는 일
- 서버에 저장되어 있는 소스코드들 과 파일을 그대로 브라우저에 전달해준다 

### 정적웹에는 어떤게 있을까 
- 회사/기관 소개페이지, 깃허브 페이지(블로그) 등
  - 서버간 통신이 거의 없기 때문에 속도가 아주 빠름

### 정적웹이 아닌 것들
- 게시판 기능이 있는 페이지
  - 댓글이나 게시판 기능이 있으면 동적웹이 유리
- 위 기능이 있으면 동적웹으로 만들어야 하는 이유?
  - 글을 하나 썼는데 그때마다 내가 방금 올라온 댓글을 보여주려면 HTML코딩을 다시 해야함.
  - 이럴때는 그냥 편하게 글이 올라오면 자동으로 보여주도록 만드는 동적웹이 유리함

### static site로 시작한 이유
- stateless : 비상태기반 이기 때문에, 정적으로 state가 없는 static site로 시작
- connectionless
- TBD


---
## 1. ajax 등장 배경
### ajax (Asynchronous Javascript And XML)?
- 비동기 자바스크립트 와 XML.
- JavaScript와 [XML]()을 이용한 비동기적 정보 교환 기법
- 서버와 통신하기 위해 [XMLHttpRequest]() 객체를 사용하는 것

### ajax 등장 이전
- ajax 등장이전까지는 페이지에 새로운 데이터를 반영하려면 서버에서 다시 데이터를 불러와야 했음 (=새로고침)
- 페이지에서 요청을 보내면
  1. 브라우저에서 폼을 채우고 이를 웹 서버로 제출/요청
  2. 웹 서버는 요청된 내용에 따라 데이터를 가공후 새로운 웹 페이지를 작성해 응답으로 돌려줌
- 이러한 불편함을 해소하기 위해 AJAX를 고안

### ajax 등장 이후
- 페이지 이동(새로고침) 없이 페이지 변경이 가능
  - 새로운 데이터를 서버에 요청 가능
  - 서버에서 데이터를 받아 작업 수행가능
  - 필요한 데이터만을 웹서버에 요청해서 받은 후 클라이언트에서 데이터에 대한 처리

### ajax 장점
- 페이지 이동이 없고 필요한 데이터만을 요청해서 받으므로 빠르게 처리 가능
- **비동기요청** 가능 = 서버 처리를 기다리지 않음.

### ajax 단점
- HTTP 클라이언트의 기능이 한정되어 있음
- 페이지 이동없는 통신으로 인한 보안 문제

---
## 2. webpack 등장 배경
### webpack?
![웹팩](/Day1/webpack.png)
- 자바스크립트 모듈화 도구 / 모듈 번들러
- 브라우저에서 사용되는 자바스크립트드들을 모듈화 하기 위한 것
  -HTML, CSS, Javscript, Images 등을 모두 각각의 모듈로 보고 이를 조합해 하나의 결과물로 만듬

### 웹팩 등장 이전
- HTML, CSS, JS 편집후 반영된 결과를 보려면 매번 브라우저 새로고침을 통해 확인
- **사용자가 서버로 많은 파일을 요청할 경우 많은 로딩시간이 소요**
  - 다수의 자바스크립트 파일이나 이미지를 요청할 때
  - 용량이 큰 파일을 로딩하려 할 때
- 느리게 로딩되는 파일만 나중에 로딩되게 할 수 없음
  - 특정 파일의 로딩시간이 길어도 이 파일이 로딩되길 기다려야 하는 현상 발생

### 웹팩 등장 이후
- 변수 유효 범위의 문제점을 ES6의 Modules 문법과 웹팩의 모듈 번들링으로 해결
- 브라우저별로 요청을 제한 
  - 성능/속도 개선 
    - 다수의 파일을 요청하는 것을 막아 갑자기 느려지는 현상을 방지
  - 웹팩을 이용해 파일을 합쳐 놓으면 제약을 피할 수 있음
  - 웹팩을 이용해 모듈을 불러올 타이밍을 정함
    - 특정 모듈을 불러오는데 시간이 오래 걸리는 경우 이를 맨나중에 로딩할 수 있게 지정가능
  - 초기 페이지 로딩 속도를 높이기 위해 **나중에 필요한 자원들은 나중에 요청**하는 레이지 로딩(Lazy Loading)

### 웹팩 문제점
- 번들링한 파일의 파일크기가 엄청 클경우
  - code spliting
    1. bundle 내부 확인
    2. 크기를 많이 차지하는 모듈 확인
    3. 실수로 번들에 추가된 모듈 발견
    4. **dynamic import 를 통해 해소**


---
## 3. SPA 등장배경
### SPA (Single Page Application)?
- 단일 페이지로 구성되어 있는 웹앱
- 화면 전환시 필요한 데이터를 요청해서 리프레쉬<small>([데이터를 서버사이드에서 HTML으로 전달받는](#ssr-server-side-rendering))</small>게 아니라 필요한 데이터만 서버로부터 **JSON**으로 전달 받아 동적으로 렌더링함

> Rendering? 요청받은 내용을 브라우저 화면에 표시하는 것

### SPA가 사용하는 방식
- [CSR](#csr-clien-side-rendering)방식 사용
  - 최초 한번만 페이지 전체를 로딩한 후 이후 필요한 데이터만 요청하여 쓰는 방식

### CSR (clien side rendering)?
- 요청한 클라이언트측에서 자바스크립트가 html을 로딩
- 브라우저가 렌더링을 담당

### CSR 과정
1. HTML 다운로드
2. JS 다운로드  
3. JS 실행 
4. 서버에 데이터 요청 (API 요청)
5. 페이지 확인

### CSR 장점
- 필요한 부분만 다시 읽어들임
  - 전체 페이지를 다시 읽어들이는 [SSR](#ssr-server-side-rendering)보다 빠른 화면구성 속도
  - 화면 이동이 빠름 (UX적 측면)
    - ex) 페이지 이동할 때 화면깜빡임이 없음 
- 네이티브 앱과 유사한 사용자 경험을 제공
  - 유저 입장에서 편리한 사용성
  - 컴포넌트 단위로 개발이 가능해져 유지보수에 매우 용이
  
### CSR 단점
- 초기 구동/로딩 속도가 느림
  - 처음 html, javascript 등을 읽어들이고 화면에 보여주는 시간
  - 하지만 처음 로딩 이후에는 [SSR](#ssr-server-side-rendering)보다 빠른 속도를 보여줌
- [검색엔진최적화(SEO)](#seo-search-engine-optimization)가 되지 않음
  - 처음 로딩하는게 HTML만 있는 페이지 = 구성요소들이 아직 불완전 하기 떄문에 검색이 안됨
- 구현하는데에 드는 시간이 SSR보다 더 들 수 있음

---
## 4. SSR 등장배경
### SSR (Server Side Rendering)?
- 사용자가 웹페이지에 접근할 때, 서버에 페이지를 요청을 하면 서버에서는 html, view 와 같은 리소스들을 해석하고 렌더링하여 사용자에게 페이지를 반환 
  - 서버에서 사용자에게 보여줄 **페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식**


### SSR이 사용되는 곳?
- JSP/Servlet의 아키텍처
  - JSP는 서버사이드 언어 
  - PHP/JSP처럼 서버에서 렌더링 해서 반환해주는 서버사이드 언어들 방식이 SSR

### SSR 과정
1. 서버에 요청
2. 서버에서 렌더팅 한 HTML 반환 
3. HTML 그대로를 사용자는 조회

### SSR 장점
- 데이터가 매핑된 상태로 반환되기 때문에 브라우저에 바로 페이지를 돌려줄 수 있음
- [검색엔진최적화(SEO)](#seo-search-engine-optimization)에 문제없음
  - 처음 로딩하는게 HTML만 있는 페이지가 아니라 완전 페이지이기 때문에 검색가능
- 초기 구동속도가 더 빠름

### SSR 단점
- 페이지를 구성하는 속도가 느림
  - 매번 전체페이지를 랜더링하는 방식
  - HTML 페이지는 볼 수 있으나 JS 구성이 느릴경우 페이지를 조작하지 못함
  - 필요없는 부분까지 재 로딩하므로 비효율적  
  - 속도: CSR > SSR


### SSR 과 CSR 비교
![CSR vs SSR](/Day1/CSRvsSSR.png)

---
## 5. SSG 재등장 배경
### SSG (Static Site Generation)?
- **정적사이트생성기**
  - ex) Gatsby, GitBook, HUGO, jekyll ...
- SSR 처럼 서버를 쓰지만 서버사이드언어를 마크업하는데에 쓰지않음.
- 리액트 같은 **자바스크립트 라이브러리나 프레임워크를 사용**
- 마크업이 사용자 기기에서 일어나는게 아니라 서버에서 일어나는것이 핵심
- CDN을 사용

### SSG로 다시 돌아온 이유 
> 내 사이트가 검색이 안돼 ..
- SPA, CSR방식을 쓰다보니 [검색엔진최적화(SEO)](#seo-search-engine-optimization)가 안되는 문제가 존재
- 너무 많은 자원을 요청하고 로딩하려다 보니 기기에 부하가 걸림

### SSG로 부하 감소 및 검색최적화
> 다시 정적사이트를 활용하자 하지만 서버는 덜 쓰자
- SSR은 서버사이드 언어를 써서 렌더링하는데 시간이 비교적 오래 걸린다는 단점이 존재
- CSR은 검색엔진최적화가 안된다는 단점이 존재
- 위 두 문제를 해결
  - 한번의 빌드후 [CDN](#cdn)을 통한 배포를 통해 정적 사이트 처럼 사용 가능 
  - 사전에 빌드 해놓은 결과 물이 보여지므로 로딩이 빠름
  - 렌더링되어 진 결과물이 보여지므로 검색엔진최적화 가능
  - 서버를 사용해도 서버에서는 HTML을 더이상 렌더링하지 않으므로 속도가 느려지지 않음.

### SSG 장점
- 사전 렌더링을 통해 바로 정적사이트로 보여주므로 속도가 빠름
- 검색엔진최적화 가능
- 서버사이드 로직을 기다릴 필요가 없음
  - 필요 하다면 서버와 연결을 할 수 있음
  - ex) Next.js, Gatsby
    - 리액트를 사용해서 빌드할때 데이터를 불러오는 웹앱을 만들 수 있음
- 서버가 필요 없음 

### SSG 단점
- 정적사이트 특성상 새 업데이트 사항이 생기면 다시 빌드해주어야 반영됨
- ex) Next.js, Nuxt.js 
- SSG에서 ajax call을 한다면?
  - SEO가 무너질 수 있음
    - 이점은 meta tag 정보가 갱신 가능 = SEO 일부 커버 가능

---

## 부록.
### 동적웹 (Sematic Engine Optimization)?
- 동적웹은 서버에서 요청정보를 처리한 후에 제작된 HTML를 반환 
  - 상황, 시간, 요청에 따라 달라짐
  - ex) 네이버/티스토리 블로그, 게시판기능이 있는 홈페이지 등

### 마크업언어? 
- 태그 등을 이용하여 문서나 데이터의 구조를 명기하는 언어 (HTML, XML, SVG등이 해당)
### 마크업
- 마크업 언어를 통해 브라우저에 명령을 내리는 것
  > 이건 이렇게 표시하고 ...  저건 저렇게 표시하고..
- 정보를 수집하는 검색 엔진에게 정확한 자료를 제공하기 위함
  > 검색엔진최적화!
- 문서를 구조적으로 표시하기 위한 것이 핵심 개념
  > 유지보수/협업 하기 편리하게 마크업 하는 것이 좋음 (한눈에 태그를 보고도 간단 명료하게 파악할 수 있는 문서)
#### mark를 up한다
- html처럼 각 tag들의 attribute들이 추가
  - mark(tag, attribute)
  - up(추가)

### [SEO (Search Engine Optimization)?](/Day1/_seo/README.md)
- 검색엔진최적화
  - 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업

### [CDN (Content Delivery Network)?](/Day1/_cdn/README.md)
- 
- 멀리 있는 사용자에게 컨텐츠를 더 빠르게 제공할 수 있게 해줌
- 느린 응답속도 개선
- 병목 현상 / 서버다운을 예방
#### CDN 작동원리
1. 최초 요청에 결과를 사용자에게 반환하면서 동시에 CDN 캐싱장비에 저장
2. 이후 모든 요청을 CDN 업체에서 지정하는 만료시점까지 CDN 캐싱장비에서 전송

## JAMstack
- **J**avascript
- **A**PI
- **M**arkup

---
<small>[목차로 돌아가기](/README.md)</small>