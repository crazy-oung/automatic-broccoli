<details>
  <summary>목차</summary>
  <div markdown="1">

- [DAY3 js](#day3-js)
  - [1. script 언어의 특징](#1-script-언어의-특징)
    - [스크립트 언어 (Scripting language)?](#스크립트-언어-scripting-language)
      - [스크립트 언어 종류](#스크립트-언어-종류)
    - [스크립트 언어의 장점](#스크립트-언어의-장점)
    - [스크립트 언어의 단점](#스크립트-언어의-단점)
    - [V8 (자바스크립트 엔진)?](#v8-자바스크립트-엔진)
    - [컴파일 언어 (Compiled language) ?](#컴파일-언어-compiled-language-)
      - [컴파일 언어 종류](#컴파일-언어-종류)
    - [컴파일 언어 장점](#컴파일-언어-장점)
    - [컴파일 언어 단점](#컴파일-언어-단점)
    - [스크립트 언어를 쓰는 이유](#스크립트-언어를-쓰는-이유)
    - [JIT (Just In Time)?](#jit-just-in-time)
    - [JIT 장담점](#jit-장담점)
      - [정적컴파일 vs JIT vs 인터프리터](#정적컴파일-vs-jit-vs-인터프리터)
    - [AJIT (Adaptive Just In Time)](#ajit-adaptive-just-in-time)
    - [자바스크립트 (Javascript) ?](#자바스크립트-javascript-)
    - [자바스크립트 특징](#자바스크립트-특징)
    - [자바스크립트의 Prototype](#자바스크립트의-prototype)
      - [자바스크립트의 프로토타입 오브젝트](#자바스크립트의-프로토타입-오브젝트)
      - [프로토타입 체이닝 (Prototype Chainig) - Prototype Link](#프로토타입-체이닝-prototype-chainig---prototype-link)
      - [console.log와 window.open](#consolelog와-windowopen)
  - [2. DOM과 가상DOM](#2-dom과-가상dom)
    - [DOM (Document Object Model)](#dom-document-object-model)
    - [DOM에서 중요한 데이터 타입들](#dom에서-중요한-데이터-타입들)
    - [가상 DOM (Virtual DOM)?](#가상-dom-virtual-dom)
  - [3. web storage에 대한 이해 cookie, session storage, local storage](#3-web-storage에-대한-이해-cookie-session-storage-local-storage)
    - [웹 스토리지 (Web Storage)?](#웹-스토리지-web-storage)
    - [로컬 스토리지 (Local Storage)?](#로컬-스토리지-local-storage)
    - [세션 스토리지 (Session Storage)?](#세션-스토리지-session-storage)
    - [웹 스토리지의 장점](#웹-스토리지의-장점)
    - [쿠키 (Cookie)?](#쿠키-cookie)
    - [쿠키 단점](#쿠키-단점)
    - [세션 (Session)?](#세션-session)
    - [세션 장점](#세션-장점)
    - [캐시 (Cash)?](#캐시-cash)
    - [캐시 장점](#캐시-장점)
  - [4. bundling 그리고 webpack의 역할](#4-bundling-그리고-webpack의-역할)
    - [웹팩](#웹팩)
    - [모듈 번들러](#모듈-번들러)
    - [Webpack 해주는 역할](#webpack-해주는-역할)
    - [Node.js와 NPM](#nodejs와-npm)
    - [package.json](#packagejson)
    - [package.json 주요 구성](#packagejson-주요-구성)
    - [uglify](#uglify)
  - [5. webpack-dev-server](#5-webpack-dev-server)
    - [Webpac-Dev-Server ??](#webpac-dev-server-)
    - [Webpac-Dev-Server 동작 원리](#webpac-dev-server-동작-원리)
    - [devServer 속성](#devserver-속성)
  - [부록](#부록)
    - [JVM (Java Virtual Machine) ?](#jvm-java-virtual-machine-)
  - [- 자바 컴파일 해주는 자바 가상 머신](#--자바-컴파일-해주는-자바-가상-머신)
  - [작성예정](#작성예정)
  - [Reference](#reference)
  </div>
</details>

---

# DAY3 js
## 1. script 언어의 특징

### 스크립트 언어 (Scripting language)?
> 인터프리터 언어(Interpreter language) / 해석형 언어라고도 함
- 컴파일이 아닌 인터프리터 방식 사용
  > 인터프리터(Interpreter) 방식? 프로그래밍 언어의 소스 코드를 바로 실행
- 기존에 이미 존재하는 소프트웨어를 제어하기 위한 용도로 쓰이는 언어
- 소프트웨어를 제어
  - 단일 응용프로그램보다는 응용프로그램을 제어하기 위한 목적으로 많이 사용함
- 빠르게 배우고 작성하기 위해 고안

#### 스크립트 언어 종류
- python, js(client-side), php(server-side), HTML, Ruby 등
  > - 클라이언트 사이드 (client-side)? 클라이언트 측에서 수행하는 처리(브라우저가 서버에서 수신한 HTML 문서를 해석해 화면에 표시)(
  > - 서버 사이드(server-side)? 서버 측에서 수행하는 처리(요청한 HTML 문서에 서버 사이드 스크립트 언어의 코드가 포함되어 있으면, 서버가 이를 처리후 결과를 브라우저로 전송)
### 스크립트 언어의 장점
- 단순하고 쉬운 문법 = 개발 속도 빠름 
  - 문법적 제약이 비교적 적음
- 실시간으로 변화 관찰 가능
- 플랫폼에 제약이 없음
  - 운영체제(기계)언어로 컴파일하지 않기 때문에 제약 없이 실행

### 스크립트 언어의 단점
- 실행 속도가 느림
  - 컴파일 과정이 없으면 기계어로 변환되는 과정이 없음
  - 사람에게 친화적인 언어 != 기계에게 친화적인언어 
    - 그러므로 기계는 해당 언어를 번역하느라(컴파일 하지않은 언어) 느림
  - 이 단점은, [JIT(Just In Time)](#jit-just-in-time) 방식을 사용해 실행 속도를 획기적으로 높여 보완됨
    - **[V8](#v8-자바스크립트-엔진)에서 이를 사용**
- 정밀한 연산을 요구할 때는 적합하지 않음
  - ex) 과도한 파일 연산
- 디버깅이 어려움
  - 코드 실행시 오류가 발견되기 떄문에 디버깅이 수월하지 않을 수 있음

### V8 (자바스크립트 엔진)?
- 웹 브라우저를 만드는 데 기반을 제공하는 오픈 소스 자바스크립트 엔진
- **자바스크립트를 바이트코드(bytecode)로 컴파일하고 실행함**
  > 이 같은 방식(바이트코드 컴파일 후 실행)을 [**JIT**](#jit-just-in-time)라고 하지
- **자바스크립트 실행속도가 빨라진 이유**
- 크로스 플랫폼이며 크로미움(크롬,엣지,웨일 등) 기반 브라우저에 탑재되어 있음
- 독립적으로 실행 가능 
   -  C++로 작성됨 
      - C++로 작성된 응용 프로그램의 일부로 작동가능
  
### 컴파일 언어 (Compiled language) ?
- 코드를 컴파일(기계어로 변환)하여 CPU/메모리를 통해 읽어와 실행
  - 스크립트 언어는 인터프리터 방식이라면 컴파일 언어는 **정적 컴파일 방식**.
  > 컴파일(Compile)? 작성한 코드를 기계어로 변환하는 과정
#### 컴파일 언어 종류
- C, C++, Java, Kotlin 등

### 컴파일 언어 장점
- **속도 빠름**
  - 실행전 코드를 컴파일하여 기계어로 변환 = 기계가 작업을 빠르게 수행가능

### 컴파일 언어 단점
- 문법적 제약이 많음
- 운영체제에 따라 개별로 작업해야함 
  - 컴파일을 수행한 운영체제별로 기계어가 다르기 떄문
    - 자바 같은 경우 [JVM](#jvm-java-virtual-machine)이 이를 해소 
      > - JVM이 인터프리터 역할을 수행함 
      >  ![JVM 구조](/Day3/jvm.png) 
      > <small>자세한건 <a href="#작성예정">백엔드 기본</a>에서.</small>
      > - 자바언어(.class) 컴파일 -> 자바 바이트코드(.java) 생성 -> JVM이 이를 해석해 기계어로 번역 -> 작동
      >   - 이 과정은 기계어로 바로 번역하는게 아니라 바이트 코드 생성이라는 과정을 거쳐 기계어로 번역 되기 떄문에 느릴 수 있음
      > - 그러나 [JIT(Just In Time)](#jit-just-in-time)방식을 이용해 느리다는 단점을 극복함

### 스크립트 언어를 쓰는 이유
- 수정을 자주해야 할때 사용 / 실시간 변화를 봐야 할 때
  - 수정을 자주 하는데 수정할 때마다 매번 컴파일을 할 경우 시간도 들고 양이 많아질수록 시간이 더더욱 중가

### JIT (Just In Time)?
> - 동적 번역이라고도 함
> - 또는, JITC (Just In Time Compilation)
- 실제 실행 시점에 바이트코드를 기계어로 변환
  - 정적 컴파일 처럼 미리 컴파일 하는 방식이 아님
-  NodeJs, JVM 런타임 등이 사용

### JIT 장담점
- 장점
  - 컴파일언어처럼 최적화를 일부에 적용할 수 있음
  - 실제 실행 시점에 바이트코드를 기계어로 변환
    - 기존 인터프리터 방식의 느린 실행속도를 개선
    - 컴파일 과정이 한번에 일어나 초기실행속도가 느릴 순 있어도 기계어로 변환한게 수행시간이 인터프리터 보다 빠름
  - 사용 빈번한 코드들을 기계어로 변환후 저장 -> 재사용 할 때 저장해둔 변환된 기계어 코드를 사용
- 단점
  - 초반에 저장을 위해 미리 메모리를 확보해두는 등의 선행작업이 있어 초기 실행 속도가 느릴 수 있음
    - **그러나,** 바이트코드를 사용 할 때마다 네이티브 코드(기계어)로 변환하는 작업이 즐어 실행속도가 빨라짐
  - 코드가 재사용 될 가능성이 적거나 규모가 작은 프로그램의 경우 쓸데없이 위 과정때문에 되려 시간이 길어질 수 있음
    - 옛날 JS의 경우 화면이 그려지는 부분에만 관여하는데, 이 경우 쓸데없이 시간이 늘어나게되는 것
    - 그래서 화면의 레이아웃만 제어하는 스크립트의 경우는 비효율적
  - 자바스크립트처럼 자료형에 제약이 없이 **들어가는 값에 따라 변수의 형이 달라지는 언어의 경우**
    - 자료형이 자꾸 바뀌는 코드라묜 이런 코드를 제어하는 기계어가 많아져서 JIT도 소용없음 다시 느려짐

#### 정적컴파일 vs JIT vs 인터프리터
- 성능: 정적컴파일 > JIT > 인터프리터

### AJIT (Adaptive Just In Time) 
> 또는, AJITC (Adaptive Just In Time Compilation)
- 기존 JIT 를 업그레이드 한 버전
- 사용 빈도수에 따라 유동적으로 서로 다른 최적화 수준을 적용하는 방식
  - 모든 코드에 최적화를 하지 않음 = JIT의 문제점 해결
  - 모든 코드는 인터프리터로 수행되되, 자주 사용한느 코드의 경우 JIT를 사용 = 효율성 up
- 크롬 V8에서 사용
  - 그럴일은 없겠지만 한 변수에 자료형을 다르게 집어넣어 해당 변수의 자료형이 자주 바뀌면 이또한 효율성은 떨어지게됨

### 자바스크립트 (Javascript) ?
- 동적으로 컨텐츠를 바꾸거나 멀티미디어를 다루는 등의 일을 하는 스크립트 언어 
  - 브라우저의 DOM API를 통해 사용자 인터페이스를 업데이트/제어 (HTML/CSS 수정)
    - DOM 형성 전에 자바스크립트 실행시 오류
      - 아직 만들어지지도 않은 HTML이나 CSS를 제어할 수 없음

### 자바스크립트 특징
- 인터프리터 방식을 사용하므로 위에서 아래로 순차적으로 실행하며 즉시 결과 반환
- 자바스크립트의 [프로토타입 체이닝(Prototype Chaining)](/Day3/_es/README.md)
  - class 를 사용함,  ES6에서 등장
  - **주의,** Java의 class가 아님. 이를 묘사하기 위해 [프로토타입](#자바스크립트의-prototype) 개념이 나옴
  - 그래서 프로토타입 기반 언어라고 부르기도함
- [ECMAScript](/Day3/_es/README.md) 사양을 따른다.
  - ECMAScript가 나온 배경에는 자바스크립트가 있음 
  - [ES6에 대해 이해하자.](/Day3/_es/README.md)
  
### 자바스크립트의 Prototype
- 부모 요소를 만들어서 객체를 그 하위에 상속시키는 개념을 구현
  - 진짜로 상속이 존재한다는 게 아니라 **`프로토타입으로 상속을 구현했다.`** 라고 봐야함
  - 이를 쉽게 하기 위해 문법적으로 ES6에서 만들어 버린게 class개념
  - **결론,** 프토토타입으로 클래스/상속기능을 구현한 것
  
#### 자바스크립트의 프로토타입 오브젝트
> ``` 
>   function name() { 
>     // 함수 로직
>   }
>   name.prototype.age = 2; // 객체의 prototype 조작
>   const myName = new Name(); // 함수로 객체 인스턴스 생성, constructor 예약어로 만듬
> ```
- 자바스크립트에서는 객체가 생성되면 항상 함수로써 생성이됨 (겍체, 함수, 배열 등등)
  - ` const myName = {}; ` 로 초기화했다면 `const myName = new Object()` 로 생성되는 거나 마찬가지인 개념
- 그래서 생성된 객체들은 프로토타입 객체(부모) 생성과 함께 연결(프토토타입)하게 됨
  > ![JS Prototype Object](/Day3/js_prototype.png)
  - 생성된 프로토타입 객체는 `constructor`와 `__proto__`를 가짐
    - `constructor`: 프로토타입 객체로 인스턴스 생성시 new 로 객체 생성
    - `__proto__`: 인스턴스 생성시 프로토타입 객체와의 연결 관계를 만듬

#### 프로토타입 체이닝 (Prototype Chainig) - Prototype Link
- 프로토타입 체이닝을 만들어주는 우리의 프로토 `__proto__`
  - 프로토는 클래스 개념처럼 생성된 변수나 함수를 상속해서 쓸 수 있게 해주는 기능을 구현한 것
- 프로토타입 속성은 함수만 갖지만 `__proto__` 는 모든 객체가 가짐
    > ![프로토가 만들어진 모습](/Day3/proto.png)
    - 따라서, 인스턴스는 프토토타입 객체의 변수를 가져와 사용하는 것이 가능해짐
    - 가져오고자 한 데이터가 없다? → 그 상위에 있는 객체의 프로토타입 객체까지 올라가서 확인
- 처음 초기화를 진행한 후 `null` 이 아니라 `undefined`가 뜨는 이유가 여기서 기인
  - 거슬러 거슬러 올라갔는데 없음. = undefined 리턴
  - 객체보려고 콘솔에 쳤는데 이상한게 바리바리 나오는 이유가 여기있음.
  - ![프로토 모습](/Day3/obj.proto.png)
- 이모든 과정, `__proto__` 를 통해 상위 프로토타입들과의 체인처럼 연결되어 있어서 이를 Prototype Chaining 이라 부름
- 프로토타입이 생성되면 프로토타입 오브젝트와 프로토타입 링크가 함께 가는 것

#### console.log와 window.open

---
## 2. DOM과 가상DOM
> ![DOM 프로세스](/Day3/dom_process.png)
> DOM트리와 웹페이지를 보는 과정 [바로가기](/Day2/README.md#dom-document-object-model)
### DOM (Document Object Model)
- 문서 객체 모델(Document Object Model) HTML, XML 문서의 프로그래밍 interface
- - W3C 표준으로 문서의 구조화된 표현을 제공
- 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공, 문서 구조, 스타일, 내용등을 변경가능하게 해줌 
- 구조화된 노드와 속성,메소드 를 갖고 있는 객체를 문서를 표현
  - 웹 페이지를 스크립트 또는 프로그래밍 언어들에서 사용될 수 있게 연결시켜주는 역할을 담당
- 웹은 일종의 문서임, 문서는 브라우저에서 해석되어서 나타나며 이를 저장/조작하는 방법을 제공하는게 DOM인 셈
  - 이같은 조작에는 자바스크립트와 같은 스크립트 언어를 사용
-  정적 문서의 요소들을 객체로 구성, 브라우저에서 실행되는 스크립트가 HTML, XML 등의 정적 문서의 요소에 동적으로 접근하고 업데이트할 수 있도록 하는 언어 중립적인 API

### DOM에서 중요한 데이터 타입들
- **`document`**
  - DOM의 루트
  - DOM 트리에 진입할 때 document에서부터 접근하게됨
- `element`
  - ` document.createElement()`
- `nodeList`
  - `element` 배열
  - `document.getElementsByTagName() `
- `attribute`
- `nameNodeMap`
- **`navigator`**
- **`window`**

### 가상 DOM (Virtual DOM)?
- 기존의 DOM에서 탐색시간이 오래걸린다는 단점을 보완하기 위해 나온 개념 
- 기존의 DOM은 생성되고 나서 변경사항이 생기면 렌더트리를 다시 만들어서 다시 그리는 과정을 반복함
  - SPA같은 경우 효율성 떨어짐
- 화면에 변화가 나타나기 전에 가상 DOM을 만들어 그곳에 변화를 얹은 후 그 결과를 실제 DOM에 전달 
  - 브라우저 내의 연산의 양이 줄어 성능이 개선됨
  - 가상돔은 렌더링이 아직 일어나지 않기 때문에 연산비용이 적은것
    - 모든 변화를 한번에 묶어서 진행하면 레이아웃이나 리렌더링의 규모는 커질 수 있지만,
    - **이 과정이 반복적으로 일어나지 않고 한번만 일어나게 됨 = 연산횟수가 줄어듬**
- 가상돔이 하는 역할
  > - 가상돔 없어도 변화가 있을 때 해당 변화는 DOM fragment 에 적용해서 DOM으로 던지면 됨
  > - DOM 객체에 대한 다수의 접근을 필요로하는 작업을 수행할 때, 리플로우가 일어나지 않게 최적화 할 수 있음
  - 그런데도 가상돔을 쓰는 이유는 가상돔이 이 모든 작업을 자동으로 처리
    - 변경된 부분을 알아서 파악하고 있음 (어떤게 어떻게 바뀌었는지 기억함)
- 각 변화들의 동기화 작업을 거치지 않고 모든 작업을 하나로 묶을 수 있음
  - 컴포넌트가 DOM 조작 요청을 할때 다른 컴포넌트들과 상호작용을 하지 않음
  - 특정 DOM을 조작할 예정이거나 조작했다 라는 정보를 공유할 필요가 없어지는 것

---
## 3. web storage에 대한 이해 cookie, session storage, local storage
> - 각 스토리지들의 자원 저장 위치
> - 데이터를 어떤 웹 스토리지에 저장할 것인지의 기준

### 웹 스토리지 (Web Storage)?
- 서버가 아닌, 클라이언트에 데이터를 저장할 수 있도록 지원하는 HTML5의 기능
- 5MB 까지 저장공간 이용가능 (큰 용량)
- Key, Value 형태
- 클라이언트에 대한 정보를 저장
- 로컬 스토리지 (local Storage)와 세션 스토리지 (session Storage) 존재

### 로컬 스토리지 (Local Storage)?
- 브라우저에 영구적으로 데이터를 저장
  - 브라우저 꺼도 데이터 유지됨
  - ex) 자동 로그인
- 도메인별로 각각 존재함 
  - 다른 도메인의 스토리지에는 접근 불가
- 내 컴퓨터의 자원을 사용
- `localStorage.setItem()`, `localStorage.getItem()`

### 세션 스토리지 (Session Storage)?
- 각 세션마다 데이터가 개별적으로 저장
  - 브라우저 탭별로 개별 데이터가 저장, 비회원 장바구니
- 세션 종료/브라우저 탭 닫을시 삭제
  - ex) 일회성 로그인 정보
  - 같은 도메인에 접근해도 세션이 다르면 거부당함
- HTML5를 지원하지 않는 브라우저의 경우 사용 불가
- `sessionStorage.setItem()`, `sessionStorage.getItem()`

### 웹 스토리지의 장점
- 쿠키보다 더 많은 정보를 저장가능

### 쿠키 (Cookie)? 
- 서버와 클라이언트 간의 지속적인 데이터 교환을 위해 만들어짐
  - 매 서버 요청시마다 쿠키 정보를 함께 전송함
    - 서버에 부담이 될 수도 있음
  - HTTP 요청 상태에 '나' 임을 알림
- 서버와 로컬에 정보를 저장
  - ex) 다시 보지 않기 
- 만료기한 존재
- 4KB 까지 저장공간 이용가능
  - 브라우저 메모리 혹은 하드디스크에 저장
- `setCookie()`, `getCookie()`

### 쿠키 단점
- 불필요한 정보 마저 서버로 전송 할 수 있음
  - 용량을 과사용하게됨
  - 데이터 낭비
- 매 서버 요청시마다 쿠키 정보를 함께 전송 = 서버에 부담
- 다른 도메인에서 요청할 때도 자동 전송가능, 누구나 열람 가능 = 보안성 낮음

### 세션 (Session)?
- 서버에 정보를 저장
- 중요한 정보 저장할 때 사용
  - ex) 로그인 정보 
- 브라우저를 종료할 때까지 유지

### 세션 장점
- 정보를 서버에 저장 = 세션 정보 탈취가 쉽지 않음 = 보안성 높음

### 캐시 (Cash)?
- 리소스 임시 저장
  - 방문했던 웹페이지를 재방문 할때 로컬에 저장된 데이터를 통해 열람
  - 서버를 거치지 않고도 열람 가능

### 캐시 장점
- 재방문 할 때 빠른 속도로 열람 가능  
  - 페이지 로딩 속도 개선됨


---
## 4. bundling 그리고 webpack의 역할
### 웹팩
- ES6/ES7 자바스크립트 코드를 작성할 수 있음 (Babel을 이용)
- 코드를 압축 또는 최적화
- SCSS 같은 소스코드를 CSS로 전처리
- HMR(Hot Module Replacement) 사용가능
  
### 모듈 번들러
- 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고 이를 하나로 조합하여 병합된 하나의 결과물로 만듬

### Webpack 해주는 역할
> 프로젝트 개발환경 세팅개념 (config를 잘 세팅하는 게 중요)
- HTML, CSS, JS 압축
  - 배포되는 파일의 크기를 감소 = 페이지 로딩 감소
  - 자바스크립트를 모듈로 작성 = 각각의 파일에 대해서 script 태그 별도로 불필요 
- 이미지 압축
- CSS 전처리기 변환
- 레이지 로딩
- npm 패키지 사용
  - 원하는 프론트엔드 패키지 사용가능
- HMR = 생산성 향상
  - 코드를 저장할 때 즉시 리프레시로 바로 확인가능

###  Node.js와 NPM
- `Node.js` : 브라우저 밖에서도 자바스크립트를 실행할 수 있는 환경제공
- `NPM(Node Package Manager)` : 명령어로 자바스크립트 라이브러리를 설치하고 관리할 수 있는 **패키지 매니저**
  - 자바스크립트 라이브러리를 공개된 저장소에 올려놓고 npm 명령어로 다운로드 가능
- 설치후 해당 프로젝트에서 사용할 자바스크립트 라이브러리를 설치

### package.json
- 사용할 라이브러리들의 의존성 설정
  - 설치 옵션으로 `-D` 설정할 경우 개발용 라이브러리
  - 개발 할때 쓰는 라이브러리들
    - webpack : 빌드 도구
    - eslint : 코드 문법 검사 도구
    - imagemin : 이미지 압축 도구

### package.json 주요 구성
- scripts 
- dependencies (배포 라이브러리)
- devDependencies (개발 라이브러리)


### uglify


---
## 5. webpack-dev-server
### Webpac-Dev-Server ??
- 빠른 실시간 리로드 기능을 갖춘 개발 서버
- 메모리 컴파일을 사용하기 때문에 컴파일 속도 빠름
- webpack.config.js에 devServer 옵션을 통해 옵션 지정해 사용 가능

###  Webpac-Dev-Server 동작 원리 
1. 서버 실행
2. 소스 파일 번들링
3. 메모리에 저장
4. 모듈 정보를 브라우저로 전송
5. 브라우저에서 반영된 페이지 로드

### devServer 속성
- `host`	사용될 호스트
- `contentBase`	콘텐츠를 제공할 경로
- `compress`	모든 항목에 대해 gzip압축 사용
- `hot`	webpack의 HMR(Hot Module Replacement) 기능 활성화	
- `inline`	inline 모드 활성화	
- `port`	접속 포트 설정	webpack-dev-server –port 9000
- `open`	dev server 구동 후 브라우저 열기 설정

---

## 부록
### JVM (Java Virtual Machine) ? 
- 자바 컴파일 해주는 자바 가상 머신
---
## 작성예정
- [ ] 백엔드기본


## Reference
- [JIT](https://meetup.toast.com/posts/77)